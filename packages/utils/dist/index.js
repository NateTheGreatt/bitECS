var L=Object.defineProperty;var R=(e,r)=>{for(var n in r)L(e,n,{get:r[n],enumerable:!0})};var E=!1,w=!1;function y(){if(E)return w;try{return new SharedArrayBuffer(1),w=!0,E=!0,!0}catch{return w=!1,E=!0,!1}}function A(){return y()?"grow"in SharedArrayBuffer.prototype:"resize"in ArrayBuffer.prototype}var T=(e,r,n=!1)=>{if(e instanceof ArrayBuffer){if(A()&&!n)return e.resize(r*Uint32Array.BYTES_PER_ELEMENT),e;{let t=new ArrayBuffer(r*Uint32Array.BYTES_PER_ELEMENT);return new Uint32Array(t).set(new Uint32Array(e)),t}}else{if(A()&&!n)return e.grow(r*Uint32Array.BYTES_PER_ELEMENT),e;{let t=new SharedArrayBuffer(r*Uint32Array.BYTES_PER_ELEMENT);return new Uint32Array(t).set(new Uint32Array(e)),t}}};var I={};R(I,{$buffer:()=>f,$dense:()=>d,$length:()=>u,$lengthBuffer:()=>U,$maxCapacity:()=>B,$onGrowCbs:()=>S});var d=Symbol("dense"),u=Symbol("length"),f=Symbol("buffer"),U=Symbol("lengthBuffer"),B=Symbol("maxCapacity"),S=Symbol("onGrowCbs");function _(e,r=e){let n=y()?new SharedArrayBuffer(e*Uint32Array.BYTES_PER_ELEMENT,{maxByteLength:r*Uint32Array.BYTES_PER_ELEMENT}):new ArrayBuffer(e*Uint32Array.BYTES_PER_ELEMENT,{maxByteLength:r*Uint32Array.BYTES_PER_ELEMENT}),t=y()?new SharedArrayBuffer(Uint32Array.BYTES_PER_ELEMENT):new ArrayBuffer(Uint32Array.BYTES_PER_ELEMENT),o=new Uint32Array(n),i=new Array(e),a=new Uint32Array(t,0,1);return{[d]:o,[f]:n,[U]:t,[B]:r,[S]:new Set,get[u](){return a[0]},set[u](p){a[0]=p},sparse:i,get dense(){return z(this)}}}function Y(e,r){e[u]+1>e[d].length&&P(e,Math.max(r,Math.min(e[u]*2,e[B])));let n=e[u];e.sparse[r]===void 0&&(e[d][n]=r,e.sparse[r]=n,e[u]++)}function O(e,r){return e.sparse[r]<e[u]&&e[d][e.sparse[r]]===r}function $(e,r){if(O(e,r)){let n=e.sparse[r];e[d][n]=e[d][e[u]-1],e.sparse[e[d][n]]=n,delete e.sparse[r],e[u]--}}function P(e,r){let n=e[f],t=n.byteLength;e[f]=T(e[f],r),e[d]=new Uint32Array(e[f]);let o={prevBuffer:n,prevSize:t,newBuffer:e[f],newSize:e[f].byteLength,didGrowInPlace:n===e[f]};for(let i of e[S])i(o)}function Z(e){return e[u]}function z(e){return new Uint32Array(e[f],0,e[u])}function ee(e,r){return e[S].add(r),()=>e[S].delete(r)}function te(e){let{cellsHigh:r,cellsWide:n,gridWidth:t,gridHeight:o,cellSize:i,defaultCellLength:a=10}=e;if(r!==void 0&&n!==void 0)t=n*i,o=r*i;else if(t!==void 0&&o!==void 0)n=Math.ceil(t/i),r=Math.ceil(o/i);else throw new Error("Invalid spatial grid options");let p=Array(n*r).fill(null).map(()=>_(a));return{cellSize:i,cells:p,width:t,height:o,cellsWide:n,cellsHigh:r}}function b(e,r){return Math.floor(r/e.cellSize)}function M(e,r,n){return r+e.cellsHigh*n}function C(e,r,n){return e.cells[M(e,r,n)]}function N(e,r){return r%e.cellsWide}function v(e,r){return Math.floor(r/e.cellsWide)}function g(e,r,n){return r>=0&&r<e.width&&n>=0&&n<e.height}function X(e,r,n,t){let o=b(e,r),i=b(e,n),a=M(e,o,i);if(!e.cells[a])throw new Error(`Cell index ${a} out of bounds of grid`);return Y(e.cells[a],t),a}function H(e,r,n){e.cells[r]&&$(e.cells[r],n)}function oe(e,r,n,t,o){return H(e,t,o),X(e,r,n,o)}function W(e,r,n=3){let t=N(e,r),o=v(e,r),i=Math.ceil(t-n/2),a=Math.ceil(o-n/2),p=Math.floor(t+n/2),G=Math.floor(o+n/2),h=[];for(let c=i;c<=p;c++)for(let s=a;s<=G;s++)g(e,c,s)&&C(e,c,s).dense.forEach(l=>h.push(l));return h}function ie(e,r,n,t){let o=b(e,r),i=b(e,n),a=M(e,o,i);return W(e,a,t)}function ae(e,r,n,t,o){let i=b(e,r),a=b(e,n),p=Math.ceil(i-t/2),G=Math.ceil(a-o/2),h=Math.floor(i+t/2),c=Math.floor(a+o/2),s=[];for(let l=p;l<=h;l++)for(let m=G;m<=c;m++)g(e,l,m)&&C(e,l,m).dense.forEach(x=>s.push(x));return s}function ue(e,r,n,t,o){let i=b(e,r),a=b(e,n),p=Math.ceil(i-t/2),G=Math.ceil(a-o/2),h=Math.floor(i+t/2),c=Math.floor(a+o/2),s=[];for(let l=p;l<=h;l++)for(let m=G;m<=c;m++){if(!g(e,l,m))continue;let x=C(e,l,m);x.dense.length&&s.push(x)}return s}var fe={...I};export{fe as SYMBOLS,te as createSpatialGrid,_ as createUint32SparseSet,y as isSabSupported,Y as sparseSetAdd,z as sparseSetGetDense,Z as sparseSetGetLength,P as sparseSetGrow,O as sparseSetHas,ee as sparseSetOnGrow,$ as sparseSetRemove,X as spatialGridAdd,ue as spatialGridBroadphaseCell,ie as spatialGridBroadphasePosition,W as spatialGridBroadphaseRadius,ae as spatialGridBroadphaseView,C as spatialGridGetCell,N as spatialGridGetCellX,v as spatialGridGetCellY,g as spatialGridInBounds,M as spatialGridIndexOf,oe as spatialGridRefresh,H as spatialGridRemove,b as spatialGridToCell};
